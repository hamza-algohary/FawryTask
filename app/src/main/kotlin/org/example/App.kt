/*
 * This source file was generated by the Gradle 'init' task
 */
package org.example

import java.time.LocalDate
import java.time.LocalDateTime
import java.util.*
import kotlin.collections.HashMap

interface Shippable {
    val name : String
    val weightInGrams : Int
}
data class Product(
    val ID : Int ,
    override val name : String ,
    val price : Double ,
    var quantity : Int ,
    val expiryDate : LocalDate? ,
    override val weightInGrams : Int ,
    val requiresShipping : Boolean,
) : Shippable

val Product.isShippable get() = weightInGrams != 0

class Store(val products : HashMap<Int , Product> = HashMap())

fun Store.addProduct(product : Product) {
    products[product.ID] = product
}

fun Store.contains(productID: Int , quantity : Int = 0) =
    products.containsKey(productID) && products[productID]!!.quantity > quantity

fun Store.priceOf(productID : Int , quantity : Int = 1) : Double =
    if (!contains(productID)) 0.0
    else products[productID]!!.price * quantity

fun Store.willBeValidAt(productID : Int , date : LocalDate) =
    contains(productID) && products[productID]!!.expiryDate.let { it==null || it.isAfter(date) }

fun Store.subtract(productID: Int , quantity: Int) {
    if(contains(productID))
        products[productID]!!.quantity -= quantity
}

//fun Store.priceOf(orderItem: OrderItem) =
//    products[orderItem.productID].let {
//        if(it==null)
//            throw InvalidProductID(orderItem.productID)
//        it.price
//    }
//
//fun Store.priceOf(order : Order) =
//    order.items.map{ priceOf(it) }.sum()


//operator fun Store.minusAssign(item : OrderItem) {
//    val product = products[item.productID]
//    if(product==null)
//        throw InvalidProductID()
//    product.quantity -=
//}

class Order (
    val items : LinkedList<OrderItem> ,
    val date : LocalDate ,
    val status : OrderStatus
)

val Order.isEmpty get() = items.isEmpty()
class OrderItem (val productID : Int , val quantity: Int)
enum class OrderStatus {
    PROCESSED,
    SHIPPED,
    DELIVERED,
    RETURNED
}

open class ShippingService {
    val shippingFeesPerGram = 0.001
    open fun checkPrice(products: List<Product>) = products.map { it.weightInGrams * shippingFeesPerGram * it.quantity }.sum()
    open fun ship(shippables: List<Shippable>) {
        println("Shipping The Following Items:\n\t ${shippables.joinToString (" , ") { it.name }} ")
    }
}

class Customer(var totalBalance : Double , val orders : LinkedList<Order> = LinkedList())

//class OrderItemError(type : Type , productID: Int) {
//    enum class Type {
//        OUT_OF_STOCK,
//        INSUFFICIENT_BALANCE,
//    }
//}

class EmptyOrderError : Exception()
class InsufficientBalanceError(val requiredMoney : Double , val currentBalance : Double) : Exception()
class OutOfStockError(val productsID: List<Int>) : Exception()
class ExpiredError(val productsID: List<Int>) : Exception()
//class InvalidProductsID(IDs : List<Int>) : Exception()


//fun Order.throwIfEmpty() {
//    if(isEmpty) throw EmptyOrderError()
//}

//fun throwIfInvalidIDsExist(order : Order , store : Store) =
//    order.items
//        .map { it.productID }
//        .filter { store.products[it]==null }
//        .apply {
//            if(isNotEmpty())
//                throw InvalidProductsID(this)
//        }

//fun throwIfOutOfStock(order : Order , store : Store) {
//    throwIfInvalidIDsExist(order,store)
//    order.items
//        .filter {
//            store.products[it.productID]!!.quantity < it.quantity || // OutOfStock
//            store.products[it.productID]!!.expiryDate?.isBefore(order.date.toLocalDate())?:false // Expired
//        }
//        .map {it.productID}
//        .apply {
//            if(isNotEmpty())
//                throw OutOfStockOrExpiredError(this)
//        }
//}

//fun Store.priceOf(orderItem: OrderItem) {
//    products[orderItem.productID]
//}

fun Order.throwIfInvalid(store : Store) =
    items.apply{
        ifEmpty { throw EmptyOrderError() }
        filter { !store.contains(it.productID) }
            .apply {
                if (isNotEmpty()) throw OutOfStockError( map { it.productID } )
            }
        filter { !store.willBeValidAt(it.productID , date) }
            .apply {
                if (isNotEmpty()) throw ExpiredError( map {it.productID} )
            }
    }

class Receipt(val products : List<Product> ,val shippingPrice : Double)

/**
 * returns list of products representing the receipt.
 */
fun placeOrder(order : Order , customer : Customer , store : Store , shippingService: ShippingService) : Receipt {
    order.throwIfInvalid(store)

    val products = order.items.map{ store.products[it.productID]!!.copy().apply { quantity = it.quantity } }

    val priceWithoutShipping = products.sumOf { it.price * it.quantity }
    val shippingPrice = shippingService.checkPrice(products)
    val totalPrice = priceWithoutShipping + shippingPrice

    if (customer.totalBalance < totalPrice)
        throw InsufficientBalanceError(totalPrice , customer.totalBalance)


    customer.totalBalance -= totalPrice
    customer.orders.add(order)
    products.forEach { product -> store.subtract(product.ID , product.quantity) }

    println("Orderred Items:")
    products.forEach{println(" - ${it.name} x${it.quantity} (${it.price} EGP)")}
    println("Subtotal Price: $priceWithoutShipping EGP")
    println("Shipping Price: $shippingPrice EGP")
    println("TotalPrice: $totalPrice EGP")

    shippingService.ship(products.filter{it.isShippable})


    return Receipt(products , shippingPrice)
}

fun newOrder(vararg items: OrderItem) = Order(LinkedList(items.toList()) , LocalDate.now() , OrderStatus.PROCESSED)

fun main() {
    val store = Store()
    store.addProduct(Product(0 , "TV" , 1000.0 , 10 , null , 20000 , true))
    store.addProduct(Product(1 , "Phone" , 500.0 , 10 , null , 200 , false))
    store.addProduct(Product(2 , "Scratch Card" , 2.0 , 100 , null , 0 , false))
    store.addProduct(Product(3 , "Milk" , 10.0 , 10 , LocalDate.now().plusMonths(7) , 1000 , false))

    val customer = Customer(5000.0)
    val shippingService = ShippingService()

    val order = newOrder(
        OrderItem(0 , 1),
        OrderItem(2 , 1),
        OrderItem(3 , 11)
    )

    try {
        placeOrder(order, customer, store, shippingService)
    } catch (e : Exception) {
        println("Error")
        when(e) {
            is ExpiredError -> {
                println("The following items are expired")
                e.productsID.forEach(::println)
            }
            is OutOfStockError -> {
                println("The following items are outof stock or unavailable")
                e.productsID.forEach(::println)
            }
            is InsufficientBalanceError -> println("Insuffecient Balance, required money is ${e.requiredMoney} while current balance is ${customer.totalBalance}")
            is EmptyOrderError -> println("Please put something in your cart")
        }
    }
}
